
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 750 – Tag Strings For Writing Domain-Specific Languages | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0750/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 750 – Tag Strings For Writing Domain-Specific Languages | peps.python.org'>
    <meta property="og:description" content="This PEP introduces tag strings for custom, repeatable string processing. Tag strings are an extension to f-strings, with a custom function – the “tag” – in place of the f prefix. This function can then provide rich features such as safety checks, lazy ...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0750/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP introduces tag strings for custom, repeatable string processing. Tag strings are an extension to f-strings, with a custom function – the “tag” – in place of the f prefix. This function can then provide rich features such as safety checks, lazy ...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 750</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 750 – Tag Strings For Writing Domain-Specific Languages</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Jim Baker &lt;jim.baker&#32;&#97;t&#32;python.org&gt;, Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;, Paul Everitt &lt;pauleveritt&#32;&#97;t&#32;me.com&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Lysandros Nikolaou &lt;lisandrosnik&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">08-Jul-2024</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.14</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps">Relationship With Other PEPs</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#valid-tag-names">Valid Tag Names</a></li>
<li><a class="reference internal" href="#tags-must-immediately-precede-the-quote-mark">Tags Must Immediately Precede the Quote Mark</a></li>
<li><a class="reference internal" href="#pep-701">PEP 701</a></li>
<li><a class="reference internal" href="#evaluating-tag-strings">Evaluating Tag Strings</a></li>
<li><a class="reference internal" href="#decoded-strings">Decoded Strings</a></li>
<li><a class="reference internal" href="#interpolation">Interpolation</a></li>
<li><a class="reference internal" href="#interpolation-expression-evaluation">Interpolation Expression Evaluation</a></li>
<li><a class="reference internal" href="#id1">Format Specification</a></li>
<li><a class="reference internal" href="#f-string-style-evaluation">f-string-style <code class="docutils literal notranslate"><span class="pre">=</span></code> Evaluation</a></li>
<li><a class="reference internal" href="#tag-function-arguments">Tag Function Arguments</a></li>
<li><a class="reference internal" href="#return-value">Return Value</a></li>
<li><a class="reference internal" href="#function-application">Function Application</a></li>
<li><a class="reference internal" href="#no-empty-decoded-string">No Empty Decoded String</a></li>
</ul>
</li>
<li><a class="reference internal" href="#html-example-of-rich-return-types">HTML Example of Rich Return Types</a></li>
<li><a class="reference internal" href="#tool-support">Tool Support</a><ul>
<li><a class="reference internal" href="#python-semantics-in-tag-strings">Python Semantics in Tag Strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How To Teach This</a></li>
<li><a class="reference internal" href="#common-patterns-seen-in-writing-tag-functions">Common Patterns Seen In Writing Tag Functions</a><ul>
<li><a class="reference internal" href="#structural-pattern-matching">Structural Pattern Matching</a></li>
<li><a class="reference internal" href="#lazy-evaluation">Lazy Evaluation</a></li>
<li><a class="reference internal" href="#memoizing">Memoizing</a></li>
<li><a class="reference internal" href="#order-of-evaluation">Order of Evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#enable-exact-round-tripping-of-conv-and-format-spec">Enable Exact Round-Tripping of <code class="docutils literal notranslate"><span class="pre">conv</span></code> and <code class="docutils literal notranslate"><span class="pre">format_spec</span></code></a></li>
<li><a class="reference internal" href="#no-implicit-string-concatenation">No Implicit String Concatenation</a></li>
<li><a class="reference internal" href="#arbitrary-conversion-values">Arbitrary Conversion Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP introduces tag strings for custom, repeatable string processing. Tag strings
are an extension to f-strings, with a custom function – the “tag” – in place of the
<code class="docutils literal notranslate"><span class="pre">f</span></code> prefix. This function can then provide rich features such as safety checks, lazy
evaluation, domain-specific languages (DSLs) for web templating, and more.</p>
<p>Tag strings are similar to <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">JavaScript tagged template literals</a>
and related ideas in other languages. The following tag string usage shows how similar it is to an <code class="docutils literal notranslate"><span class="pre">f</span></code> string, albeit
with the ability to process the literal string and embedded values:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span>
<span class="n">greeting</span> <span class="o">=</span> <span class="n">greet</span><span class="s2">&quot;hello </span><span class="si">{name}</span><span class="s2">&quot;</span>
<span class="k">assert</span> <span class="n">greeting</span> <span class="o">==</span> <span class="s2">&quot;Hello WORLD!&quot;</span>
</pre></div>
</div>
<p>Tag functions accept prepared arguments and return a string:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tag function to return a greeting with an upper-case recipient.&quot;&quot;&quot;</span>
    <span class="n">salutation</span><span class="p">,</span> <span class="n">recipient</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">args</span>
    <span class="n">getvalue</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">recipient</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salutation</span><span class="o">.</span><span class="n">title</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">!&quot;</span>
</pre></div>
</div>
<p>Below you can find richer examples. As a note, an implementation based on CPython 3.14
exists, as discussed in this document.</p>
</section>
<section id="relationship-with-other-peps">
<h2><a class="toc-backref" href="#relationship-with-other-peps" role="doc-backlink">Relationship With Other PEPs</a></h2>
<p>Python introduced f-strings in Python 3.6 with <a class="pep reference internal" href="../pep-0498/" title="PEP 498 – Literal String Interpolation">PEP 498</a>. The grammar was
then formalized in <a class="pep reference internal" href="../pep-0701/" title="PEP 701 – Syntactic formalization of f-strings">PEP 701</a> which also lifted some restrictions. This PEP
is based off of PEP 701.</p>
<p>At nearly the same time PEP 498 arrived, <a class="pep reference internal" href="../pep-0501/" title="PEP 501 – General purpose template literal strings">PEP 501</a> was written to provide
“i-strings” – that is, “interpolation template strings”. The PEP was
deferred pending further experience with f-strings. Work on this PEP was
resumed by a different author in March 2023, introducing “t-strings” as template
literal strings, and built atop PEP 701.</p>
<p>The authors of this PEP consider tag strings as a generalization of the
updated work in PEP 501.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Python f-strings became very popular, very fast. The syntax was simple, convenient, and
interpolated expressions had access to regular scoping rules. However, f-strings have
two main limitations - expressions are eagerly evaluated, and interpolated values
cannot be intercepted. The former means that f-strings cannot be re-used like templates,
and the latter means that how values are interpolated cannot be customized.</p>
<p>Templating in Python is currently achieved using packages like Jinja2 which bring their
own templating languages for generating dynamic content. In addition to being one more
thing to learn, these languages are not nearly as expressive as Python itself. This
means that business logic, which cannot be expressed in the templating language, must be
written in Python instead, spreading the logic across different languages and files.</p>
<p>Likewise, the inability to intercept interpolated values means that they cannot be
sanitized or otherwise transformed before being integrated into the final string. Here,
the convenience of f-strings could be considered a liability. For example, a user
executing a query with <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html">sqlite3</a>
may be tempted to use an f-string to embed values into their SQL expression instead of
using the <code class="docutils literal notranslate"><span class="pre">?</span></code> placeholder and passing the values as a tuple to avoid an
<a class="reference external" href="https://en.wikipedia.org/wiki/SQL_injection">SQL injection attack</a>.</p>
<p>Tag strings address both these problems by extending the f-string syntax to provide
developers access to the string and its interpolated values before they are combined. In
doing so, tag strings may be interpreted in many different ways, opening up the
possibility for DSLs and other custom string processing.</p>
</section>
<section id="proposal">
<h2><a class="toc-backref" href="#proposal" role="doc-backlink">Proposal</a></h2>
<p>This PEP proposes customizable prefixes for f-strings. These f-strings then
become a “tag string”: an f-string with a “tag function.” The tag function is
a callable which is given a sequence of arguments for the parsed tokens in
the string.</p>
<p>Here’s a very simple example. Imagine we want a certain kind of string with
some custom business policies: uppercase the value and add an exclamation point.</p>
<p>Let’s start with a tag string which simply returns a static greeting:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Give a static greeting.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;Hello!&quot;</span>

<span class="k">assert</span> <span class="n">greet</span><span class="s2">&quot;Hi&quot;</span> <span class="o">==</span> <span class="s2">&quot;Hello!&quot;</span>  <span class="c1"># Use the custom &quot;tag&quot; on the string</span>
</pre></div>
</div>
<p>As you can see, <code class="docutils literal notranslate"><span class="pre">greet</span></code> is just a callable, in the place that the <code class="docutils literal notranslate"><span class="pre">f</span></code>
prefix would go. Let’s look at the args:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Uppercase and add exclamation.&quot;&quot;&quot;</span>
    <span class="n">salutation</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salutation</span><span class="si">}</span><span class="s2">!&quot;</span>

<span class="n">greeting</span> <span class="o">=</span> <span class="n">greet</span><span class="s2">&quot;Hello&quot;</span>  <span class="c1"># Use the custom &quot;tag&quot; on the string</span>
<span class="k">assert</span> <span class="n">greeting</span> <span class="o">==</span> <span class="s2">&quot;HELLO!&quot;</span>
</pre></div>
</div>
<p>The tag function is passed a sequence of arguments. Since our tag string is simply
<code class="docutils literal notranslate"><span class="pre">&quot;Hello&quot;</span></code>, the <code class="docutils literal notranslate"><span class="pre">args</span></code> sequence only contains a string-like value of <code class="docutils literal notranslate"><span class="pre">'Hello'</span></code>.</p>
<p>With this in place, let’s introduce an <em>interpolation</em>. That is, a place where
a value should be inserted:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handle an interpolation.&quot;&quot;&quot;</span>
    <span class="c1"># The first arg is the string-like value &quot;Hello &quot; with a space</span>
    <span class="n">salutation</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># The second arg is an &quot;interpolation&quot;</span>
    <span class="n">interpolation</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Interpolations are tuples, the first item is a lambda</span>
    <span class="n">getvalue</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># It gets called in the scope where it was defined, so</span>
    <span class="c1"># the interpolation returns &quot;World&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">()</span>
    <span class="n">recipient</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">salutation</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">recipient</span><span class="si">}</span><span class="s2">!&quot;</span>

<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span>
<span class="n">greeting</span> <span class="o">=</span> <span class="n">greet</span><span class="s2">&quot;Hello </span><span class="si">{name}</span><span class="s2">&quot;</span>
<span class="k">assert</span> <span class="n">greeting</span> <span class="o">==</span> <span class="s2">&quot;Hello WORLD!&quot;</span>
</pre></div>
</div>
<p>The f-string interpolation of <code class="docutils literal notranslate"><span class="pre">{name}</span></code> leads to the new machinery in tag
strings:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">args[0]</span></code> is still the string-like <code class="docutils literal notranslate"><span class="pre">'Hello</span> <span class="pre">'</span></code>, this time with a trailing space</li>
<li><code class="docutils literal notranslate"><span class="pre">args[1]</span></code> is an expression – the <code class="docutils literal notranslate"><span class="pre">{name}</span></code> part</li>
<li>Tag strings represent this part as an <em>interpolation</em> object as discussed below</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">*args</span></code> list is a sequence of <code class="docutils literal notranslate"><span class="pre">Decoded</span></code> and <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> values. A “decoded” object
is a string-like object with extra powers, as described below. An “interpolation” object is a
tuple-like value representing how Python processed the interpolation into a form useful for your
tag function. Both are fully described below in <a class="reference internal" href="#specification">Specification</a>.</p>
<p>Here is a more generalized version using structural pattern matching and type hints:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Decoded</span><span class="p">,</span> <span class="n">Interpolation</span>  <span class="c1"># Get the new protocols</span>

<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handle arbitrary args using structural pattern matching.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">Decoded</span><span class="p">()</span> <span class="k">as</span> <span class="n">decoded</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">Interpolation</span><span class="p">()</span> <span class="k">as</span> <span class="n">interpolation</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">interpolation</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span>

<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span>
<span class="n">greeting</span> <span class="o">=</span> <span class="n">greet</span><span class="s2">&quot;Hello </span><span class="si">{name}</span><span class="s2"> nice to meet you&quot;</span>
<span class="k">assert</span> <span class="n">greeting</span> <span class="o">==</span> <span class="s2">&quot;Hello WORLD nice to meet you!&quot;</span>
</pre></div>
</div>
<p>Tag strings extract more than just a callable from the <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code>. They also
provide Python string formatting info, as well as the original text:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolations can have string formatting specs and conversions.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">Decoded</span><span class="p">()</span> <span class="k">as</span> <span class="n">decoded</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span>
            <span class="k">case</span> <span class="n">getvalue</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">conversion</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">:</span>  <span class="c1"># Unpack</span>
                <span class="n">gv</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;gv: </span><span class="si">{</span><span class="n">getvalue</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">r</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;r: </span><span class="si">{</span><span class="n">raw</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">c</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;c: </span><span class="si">{</span><span class="n">conversion</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">f</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;f: </span><span class="si">{</span><span class="n">format_spec</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">gv</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">]))</span>

    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span>

<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;World&quot;</span>
<span class="k">assert</span> <span class="n">greet</span><span class="s2">&quot;Hello </span><span class="si">{name!r:s}</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;Hello gv: World, r: name, c: r, f: s!&quot;</span>
</pre></div>
</div>
<p>You can see each of the <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> parts getting extracted:</p>
<ul class="simple">
<li>The lambda expression to call and get the value in the scope it was defined</li>
<li>The raw string of the interpolation (<code class="docutils literal notranslate"><span class="pre">name</span></code>)</li>
<li>The Python “conversion” field (<code class="docutils literal notranslate"><span class="pre">r</span></code>)</li>
<li>Any <a class="reference external" href="https://docs.python.org/3/library/string.html#format-specification-mini-language">format specification</a>
(<code class="docutils literal notranslate"><span class="pre">s</span></code>)</li>
</ul>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>In the rest of this specification, <code class="docutils literal notranslate"><span class="pre">my_tag</span></code> will be used for an arbitrary tag.
For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mytag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">args</span>

<span class="n">trade</span> <span class="o">=</span> <span class="s1">&#39;shrubberies&#39;</span>
<span class="n">mytag</span><span class="s1">&#39;Did you say &quot;</span><span class="si">{trade}</span><span class="s1">&quot;?&#39;</span>
</pre></div>
</div>
<section id="valid-tag-names">
<h3><a class="toc-backref" href="#valid-tag-names" role="doc-backlink">Valid Tag Names</a></h3>
<p>The tag name can be any undotted name that isn’t already an existing valid string or
bytes prefix, as seen in the <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals">lexical analysis specification</a>.
Therefore these prefixes can’t be used as a tag:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>stringprefix: &quot;r&quot; | &quot;u&quot; | &quot;R&quot; | &quot;U&quot; | &quot;f&quot; | &quot;F&quot;
            : | &quot;fr&quot; | &quot;Fr&quot; | &quot;fR&quot; | &quot;FR&quot; | &quot;rf&quot; | &quot;rF&quot; | &quot;Rf&quot; | &quot;RF&quot;

bytesprefix: &quot;b&quot; | &quot;B&quot; | &quot;br&quot; | &quot;Br&quot; | &quot;bR&quot; | &quot;BR&quot; | &quot;rb&quot; | &quot;rB&quot; | &quot;Rb&quot; | &quot;RB&quot;
</pre></div>
</div>
<p>Python <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">restricts certain keywords</a> from being
used as identifiers. This restriction also applies to tag names. Usage of keywords should
trigger a helpful error, as done in recent CPython releases.</p>
</section>
<section id="tags-must-immediately-precede-the-quote-mark">
<h3><a class="toc-backref" href="#tags-must-immediately-precede-the-quote-mark" role="doc-backlink">Tags Must Immediately Precede the Quote Mark</a></h3>
<p>As with other string literal prefixes, no whitespace can be between the tag and the
quote mark.</p>
</section>
<section id="pep-701">
<h3><a class="toc-backref" href="#pep-701" role="doc-backlink">PEP 701</a></h3>
<p>Tag strings support the full syntax of <a class="pep reference internal" href="../pep-0701/" title="PEP 701 – Syntactic formalization of f-strings">PEP 701</a> in that any string literal,
with any quote mark, can be nested in the interpolation. This nesting includes
of course tag strings.</p>
</section>
<section id="evaluating-tag-strings">
<h3><a class="toc-backref" href="#evaluating-tag-strings" role="doc-backlink">Evaluating Tag Strings</a></h3>
<p>When the tag string is evaluated, the tag must have a binding, or a <code class="docutils literal notranslate"><span class="pre">NameError</span></code>
is raised; and it must be a callable, or a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> is raised. The callable
must accept a sequence of positional arguments. This behavior follows from the
de-sugaring of:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">trade</span> <span class="o">=</span> <span class="s1">&#39;shrubberies&#39;</span>
<span class="n">mytag</span><span class="s1">&#39;Did you say &quot;</span><span class="si">{trade}</span><span class="s1">&quot;?&#39;</span>
</pre></div>
</div>
<p>to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="p">(</span><span class="n">DecodedConcrete</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Did you say &quot;&#39;</span><span class="p">),</span> <span class="n">InterpolationConcrete</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">trade</span><span class="p">,</span> <span class="s1">&#39;trade&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">DecodedConcrete</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;?&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>DecodedConcrete</cite> and <cite>InterpolationConcrete</cite> are just example implementations. If approved,
tag strings will have concrete types in <cite>builtins</cite>.</p>
</div>
</section>
<section id="decoded-strings">
<h3><a class="toc-backref" href="#decoded-strings" role="doc-backlink">Decoded Strings</a></h3>
<p>In the <code class="docutils literal notranslate"><span class="pre">mytag'Did</span> <span class="pre">you</span> <span class="pre">say</span> <span class="pre">&quot;{trade}&quot;?'</span></code> example, there are two strings: <code class="docutils literal notranslate"><span class="pre">r'Did</span> <span class="pre">you</span> <span class="pre">say</span> <span class="pre">&quot;'</span></code>
and <code class="docutils literal notranslate"><span class="pre">r'&quot;?'</span></code>.</p>
<p>Strings are internally stored as objects with a <code class="docutils literal notranslate"><span class="pre">Decoded</span></code> structure, meaning: conforming to
a protocol <code class="docutils literal notranslate"><span class="pre">Decoded</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Decoded</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="n">raw</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>These <code class="docutils literal notranslate"><span class="pre">Decoded</span></code> objects have access to raw strings. Raw strings are used because tag strings
are meant to target a variety of DSLs, such as the shell and regexes. Such DSLs have their
own specific treatment of metacharacters, namely the backslash.</p>
<p>However, often the “cooked” string is what is needed, by decoding the string as
if it were a standard Python string. In the proposed implementation, the decoded object’s
<code class="docutils literal notranslate"><span class="pre">__new__</span></code> will <em>store</em> the raw string and <em>store and return</em> the “cooked” string.</p>
<p>The protocol is marked as <code class="docutils literal notranslate"><span class="pre">&#64;runtime_checkable</span></code> to allow structural pattern matching to
test against the protocol instead of a type. This can incur a small performance penalty.
Since the <code class="docutils literal notranslate"><span class="pre">case</span></code> tests are in user-code tag functions, authors can choose to optimize by
testing for the implementation type discussed next.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Decoded</span></code> protocol will be available from <code class="docutils literal notranslate"><span class="pre">typing</span></code>. In CPython, <code class="docutils literal notranslate"><span class="pre">Decoded</span></code>
will be implemented in C, but for discussion of this PEP, the following is a compatible
implementation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DecodedConcrete</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="n">_raw</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">raw</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;unicode-escape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">decoded</span> <span class="o">==</span> <span class="n">raw</span><span class="p">:</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">raw</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">decoded</span><span class="p">)</span>
        <span class="n">chunk</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">raw</span>
        <span class="k">return</span> <span class="n">chunk</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span>
</pre></div>
</div>
</section>
<section id="interpolation">
<h3><a class="toc-backref" href="#interpolation" role="doc-backlink">Interpolation</a></h3>
<p>An <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> is the data structure representing an expression inside the tag
string. Interpolations enable a delayed evaluation model, where the interpolation
expression is computed, transformed, memoized, or processed in any way.</p>
<p>In addition, the original text of the interpolation expression is made available to the
tag function. This can be useful for debugging or metaprogramming.</p>
<p><code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> is a <code class="docutils literal notranslate"><span class="pre">Protocol</span></code> which will be made available from <code class="docutils literal notranslate"><span class="pre">typing</span></code>. It
has the following definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Interpolation</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">conv</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">format_spec</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span>
</pre></div>
</div>
<p>Given this example interpolation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="s1">&#39;{trade!r:some-formatspec}&#39;</span>
</pre></div>
</div>
<p>these attributes are as follows:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">getvalue</span></code> is a zero argument closure for the interpolation. In this case, <code class="docutils literal notranslate"><span class="pre">lambda:</span> <span class="pre">trade</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">expr</span></code> is the <em>expression text</em> of the interpolation. Example: <code class="docutils literal notranslate"><span class="pre">'trade'</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code> is the
<a class="reference external" href="https://docs.python.org/3/library/string.html#format-string-syntax">optional conversion</a>
to be used by the tag function, one of <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">a</span></code>, corresponding to repr, str,
and ascii conversions. Note that as with f-strings, no other conversions are supported.
Example: <code class="docutils literal notranslate"><span class="pre">'r'</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">format_spec</span></code> is the optional <a class="reference external" href="https://docs.python.org/3/library/string.html#format-specification-mini-language">format_spec string</a>.
A <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> is eagerly evaluated if it contains any expressions before being passed to the tag
function. Example: <code class="docutils literal notranslate"><span class="pre">'some-formatspec'</span></code>.</li>
</ul>
<p>In all cases, the tag function determines what to do with valid <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code>
attributes.</p>
<p>In the CPython reference implementation, implementing <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> in C would
use the equivalent <a class="reference external" href="https://docs.python.org/3/c-api/tuple.html#struct-sequence-objects">Struct Sequence Objects</a> (see
such code as <a class="reference external" href="https://docs.python.org/3/library/os.html#os.stat_result">os.stat_result</a>). For purposes of this
PEP, here is an example of a pure Python implementation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InterpolationConcrete</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">getvalue</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">conv</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">format_spec</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="interpolation-expression-evaluation">
<h3><a class="toc-backref" href="#interpolation-expression-evaluation" role="doc-backlink">Interpolation Expression Evaluation</a></h3>
<p>Expression evaluation for interpolations is the same as in <a class="pep reference internal" href="../pep-0498/#expression-evaluation" title="PEP 498 – Literal String Interpolation § Expression evaluation">PEP 498</a>,
except that all expressions are always implicitly wrapped with a <code class="docutils literal notranslate"><span class="pre">lambda</span></code>:</p>
<blockquote>
<div>The expressions that are extracted from the string are evaluated in the context
where the tag string appeared. This means the expression has full access to its
lexical scope, including local and global variables. Any valid Python expression
can be used, including function and method calls.</div></blockquote>
<p>However, there’s one additional nuance to consider, <a class="reference external" href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-names">function scope</a>
versus <a class="reference external" href="https://docs.python.org/3/reference/executionmodel.html#annotation-scopes">annotation scope</a>.
Consider this somewhat contrived example to configure captions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CaptionConfig</span><span class="p">:</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="n">figure</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s1">&gt;Figure&lt;/</span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>Let’s now attempt to rewrite the above example to use tag strings:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CaptionConfig</span><span class="p">:</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="n">figure</span> <span class="o">=</span> <span class="n">html</span><span class="s1">&#39;&lt;</span><span class="si">{tag}</span><span class="s1">&gt;Figure&lt;/</span><span class="si">{tag}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>Unfortunately, this rewrite doesn’t work if using the usual lambda wrapping to
implement interpolations, namely <code class="docutils literal notranslate"><span class="pre">lambda:</span> <span class="pre">tag</span></code>. When the interpolations are
evaluated by the tag function, it will result in <code class="docutils literal notranslate"><span class="pre">NameError:</span> <span class="pre">name</span> <span class="pre">'tag'</span> <span class="pre">is</span> <span class="pre">not</span>
<span class="pre">defined</span></code>. The root cause of this name error is that <code class="docutils literal notranslate"><span class="pre">lambda:</span> <span class="pre">tag</span></code> uses function scope,
and it’s therefore not able to use the class definition where <code class="docutils literal notranslate"><span class="pre">tag</span></code> is
defined.</p>
<p>Desugaring how the tag string could be evaluated will result in the same
<code class="docutils literal notranslate"><span class="pre">NameError</span></code> even using f-strings; the lambda wrapping here also uses function
scoping:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CaptionConfig</span><span class="p">:</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="n">figure</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="w"> </span><span class="n">tag</span><span class="p">)()</span><span class="si">}</span><span class="s1">&gt;Figure&lt;/</span><span class="si">{</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="w"> </span><span class="n">tag</span><span class="p">)()</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>For tag strings, getting such a <code class="docutils literal notranslate"><span class="pre">NameError</span></code> would be surprising. It would also
be a rough edge in using tag strings in this specific case of working with class
variables. After all, tag strings are supposed to support a superset of the
capabilities of f-strings.</p>
<p>The solution is to use annotation scope for tag string interpolations. While the
name “annotation scope” suggests it’s only about annotations, it solves this
problem by lexically resolving names in the class definition, such as <code class="docutils literal notranslate"><span class="pre">tag</span></code>,
unlike function scope.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The use of annotation scope means it’s not possible to fully desugar
interpolations into Python code. Instead it’s as if one is writing
<code class="docutils literal notranslate"><span class="pre">interpolation_lambda:</span> <span class="pre">tag</span></code>, not <code class="docutils literal notranslate"><span class="pre">lambda:</span> <span class="pre">tag</span></code>, where a hypothetical
<code class="docutils literal notranslate"><span class="pre">interpolation_lambda</span></code> keyword variant uses annotation scope instead of
the standard function scope.</p>
<p>This is more or less how the reference implementation implements this
concept (but without creating a new keyword of course).</p>
</div>
<p>This PEP and its reference implementation therefore use the support for
annotation scope. Note that this usage is a separable part from the
implementation of <a class="pep reference internal" href="../pep-0649/" title="PEP 649 – Deferred Evaluation Of Annotations Using Descriptors">PEP 649</a> and <a class="pep reference internal" href="../pep-0695/" title="PEP 695 – Type Parameter Syntax">PEP 695</a> which provides a somewhat similar
deferred execution model for annotations. Instead it’s up to the tag function to
evaluate any interpolations.</p>
<p>With annotation scope in place, lambda-wrapped expressions in interpolations
then provide the usual lexical scoping seen with f-strings. So there’s no need
to use <code class="docutils literal notranslate"><span class="pre">locals()</span></code>, <code class="docutils literal notranslate"><span class="pre">globals()</span></code>, or frame introspection with
<code class="docutils literal notranslate"><span class="pre">sys._getframe</span></code> to evaluate the interpolation. In addition, the code of each
expression is available and does not have to be looked up with
<code class="docutils literal notranslate"><span class="pre">inspect.getsource</span></code> or some other means.</p>
</section>
<section id="id1">
<h3><a class="toc-backref" href="#id1" role="doc-backlink">Format Specification</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> is by default <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not specified in the tag string’s
corresponding interpolation.</p>
<p>Because the tag function is completely responsible for processing <code class="docutils literal notranslate"><span class="pre">Decoded</span></code>
and <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> values, there is no required interpretation for the format
spec and conversion in an interpolation. For example, this is a valid usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">html</span><span class="s1">&#39;&lt;div id={id:int}&gt;{content:HTML|str}&lt;/div&gt;&#39;</span>
</pre></div>
</div>
<p>In this case the <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> for the second interpolation is the string
<code class="docutils literal notranslate"><span class="pre">'HTML|str'</span></code>; it is up to the <code class="docutils literal notranslate"><span class="pre">html</span></code> tag to do something with the
“format spec” here, if anything.</p>
</section>
<section id="f-string-style-evaluation">
<h3><a class="toc-backref" href="#f-string-style-evaluation" role="doc-backlink">f-string-style <code class="docutils literal notranslate"><span class="pre">=</span></code> Evaluation</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">mytag'{expr=}'</span></code> is parsed to being the same as <code class="docutils literal notranslate"><span class="pre">mytag'expr={expr}</span></code>’, as
implemented in the issue <a class="reference external" href="https://github.com/python/cpython/issues/80998">Add = to f-strings for
easier debugging</a>.</p>
</section>
<section id="tag-function-arguments">
<h3><a class="toc-backref" href="#tag-function-arguments" role="doc-backlink">Tag Function Arguments</a></h3>
<p>The tag function has the following signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mytag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This corresponds to the following protocol:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TagFunction</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Because of subclassing, the signature for <code class="docutils literal notranslate"><span class="pre">mytag</span></code> can of course be widened to
the following, at the cost of losing some type specificity:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mytag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>A user might write a tag string as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">args</span>

<span class="n">tag</span><span class="s2">&quot;</span><span class="se">\N{{GRINNING FACE}</span><span class="s2">}&quot;</span>
</pre></div>
</div>
<p>Tag strings will represent this as exactly one <code class="docutils literal notranslate"><span class="pre">Decoded</span></code> argument. In this case, <code class="docutils literal notranslate"><span class="pre">Decoded.raw</span></code> would be
<code class="docutils literal notranslate"><span class="pre">'\\N{GRINNING</span> <span class="pre">FACE}'</span></code>. The “cooked” representation via encode and decode would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">N{GRINNING FACE}&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;unicode-escape&#39;</span><span class="p">)</span>
<span class="s1">&#39;😀&#39;</span>
</pre></div>
</div>
<p>Named unicode characters immediately followed by more text will still produce
just one <code class="docutils literal notranslate"><span class="pre">Decoded</span></code> argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">args</span>

<span class="k">assert</span> <span class="n">tag</span><span class="s2">&quot;</span><span class="se">\N{{GRINNING FACE}</span><span class="s2">}sometext&quot;</span> <span class="o">==</span> <span class="p">(</span><span class="n">DecodedConcrete</span><span class="p">(</span><span class="s2">&quot;😀sometext&quot;</span><span class="p">),)</span>
</pre></div>
</div>
</section>
<section id="return-value">
<h3><a class="toc-backref" href="#return-value" role="doc-backlink">Return Value</a></h3>
<p>Tag functions can return any type. Often they will return a string, but
richer systems can be built by returning richer objects. See below for
a motivating example.</p>
</section>
<section id="function-application">
<h3><a class="toc-backref" href="#function-application" role="doc-backlink">Function Application</a></h3>
<p>Tag strings desugar as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="s1">&#39;Hi, {name!s:format_spec}!&#39;</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="p">(</span><span class="n">DecodedConcrete</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Hi, &#39;</span><span class="p">),</span> <span class="n">InterpolationConcrete</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span>
<span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;format_spec&#39;</span><span class="p">),</span> <span class="n">DecodedConcrete</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;!&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To keep it simple, this and subsequent desugaring omits an important scoping
aspect in how names in interpolation expressions are resolved, specifically
when defining classes. See <a class="reference internal" href="#interpolation-expression-evaluation">Interpolation Expression Evaluation</a>.</p>
</div>
</section>
<section id="no-empty-decoded-string">
<h3><a class="toc-backref" href="#no-empty-decoded-string" role="doc-backlink">No Empty Decoded String</a></h3>
<p>Alternation between decodeds and interpolations is commonly seen, but it depends
on the tag string. Decoded strings will never have a value that is the empty string:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="s1">&#39;</span><span class="si">{a}{b}{c}</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>…which results in this desugaring:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="p">(</span><span class="n">InterpolationConcrete</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">InterpolationConcrete</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">InterpolationConcrete</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
<p>Likewise:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>…results in this desugaring:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="html-example-of-rich-return-types">
<h2><a class="toc-backref" href="#html-example-of-rich-return-types" role="doc-backlink">HTML Example of Rich Return Types</a></h2>
<p>Tag functions can be a powerful part of larger processing chains by returning richer objects.
JavaScript tagged template literals, for example, are not constrained by a requirement to
return a string. As an example, let’s look at an HTML generation system, with a usage and
“subcomponent”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Menu</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">logo</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">class_</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HTML</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">html</span><span class="s1">&#39;&lt;img alt=&quot;Site Logo&quot; src=</span><span class="si">{logo}</span><span class="s1"> class=</span><span class="si">{class_}</span><span class="s1"> /&gt;&#39;</span>

<span class="n">icon</span> <span class="o">=</span> <span class="s1">&#39;acme.png&#39;</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">html</span><span class="s1">&#39;&lt;header&gt;&lt;</span><span class="si">{Menu}</span><span class="s1"> logo=</span><span class="si">{icon}</span><span class="s1"> class=&quot;my-menu&quot;/&gt;&lt;/header&gt;&#39;</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span>
<span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">attrs</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;src&quot;</span><span class="p">:</span> <span class="s2">&quot;acme.png&quot;</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="s2">&quot;my-menu&quot;</span><span class="p">,</span> <span class="s2">&quot;alt&quot;</span><span class="p">:</span> <span class="s2">&quot;Site Logo&quot;</span><span class="p">}</span>
<span class="c1"># We can also treat the return type as a string of specially-serialized HTML</span>
<span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;&lt;header&gt;&#39;</span> <span class="c1"># etc.</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">html</span></code> tag function might have the following signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">html</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HTML</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">HTML</span></code> return class might have the following shape as a <code class="docutils literal notranslate"><span class="pre">Protocol</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">HTML</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">attrs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">HTML</span><span class="p">]</span>
</pre></div>
</div>
<p>In summary, the returned instance can be used as:</p>
<ul class="simple">
<li>A string, for serializing to the final output</li>
<li>An iterable, for working with WSGI/ASGI for output streamed and evaluated
interpolations <em>in the order</em> they are written out</li>
<li>A DOM (data) structure of nested Python data</li>
</ul>
<p>In each case, the result can be lazily and recursively composed in a safe fashion, because
the return value isn’t required to be a string. Recommended practice is that
return values are “passive” objects.</p>
<p>What benefits might come from returning rich objects instead of strings? A DSL for
a domain such as HTML templating can provide a toolchain of post-processing, as
<a class="reference external" href="https://babeljs.io">Babel</a> does for JavaScript
<a class="reference external" href="https://babeljs.io/docs/#pluggable">with AST-based transformation plugins</a>.
Similarly, systems that provide middleware processing can operate on richer,
standard objects with more capabilities. Tag string results can be tested as
nested Python objects, rather than string manipulation. Finally, the intermediate
results can be cached/persisted in useful ways.</p>
</section>
<section id="tool-support">
<h2><a class="toc-backref" href="#tool-support" role="doc-backlink">Tool Support</a></h2>
<section id="python-semantics-in-tag-strings">
<h3><a class="toc-backref" href="#python-semantics-in-tag-strings" role="doc-backlink">Python Semantics in Tag Strings</a></h3>
<p>Python template languages and other DSLs have semantics quite apart from Python.
Different scope rules, different calling semantics e.g. for macros, their own
grammar for loops, and the like.</p>
<p>This means all tools need to write special support for each language. Even then,
it is usually difficult to find all the possible scopes, for example to autocomplete
values.</p>
<p>However, f-strings do not have this issue. An f-string is considered part of Python.
Expressions in curly braces behave as expected and values should resolve based on
regular scoping rules. Tools such as mypy can see inside f-string expressions,
but will likely never look inside a Jinja2 template.</p>
<p>DSLs written with tag strings will inherit much of this value. While we can’t expect
standard tooling to understand the “domain” in the DSL, they can still inspect
anything expressible in an f-string.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>Like f-strings, use of tag strings will be a syntactic backwards incompatibility
with previous versions.</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>The security implications of working with interpolations, with respect to
interpolations, are as follows:</p>
<ol class="arabic simple">
<li>Scope lookup is the same as f-strings (lexical scope). This model has been
shown to work well in practice.</li>
<li>Tag functions can ensure that any interpolations are done in a safe fashion,
including respecting the context in the target DSL.</li>
</ol>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How To Teach This</a></h2>
<p>Tag strings have several audiences: consumers of tag functions, authors of tag
functions, and framework authors who provide interesting machinery for tag
functions.</p>
<p>All three groups can start from an important framing:</p>
<ul class="simple">
<li>Existing solutions (such as template engines) can do parts of tag strings</li>
<li>But tag strings move logic closer to “normal Python”</li>
</ul>
<p>Consumers can look at tag strings as starting from f-strings:</p>
<ul class="simple">
<li>They look familiar</li>
<li>Scoping and syntax rules are the same</li>
</ul>
<p>They first thing they need to absorb: unlike f-strings, the string isn’t
immediately evaluated “in-place”. Something else (the tag function) happens.
That’s the second thing to teach: the tag functions do something particular.
Thus the concept of “domain specific languages” (DSLs). What’s extra to
teach: you need to import the tag function before tagging a string.</p>
<p>Tag function authors think in terms of making a DSL. They have
business policies they want to provide in a Python-familiar way. With tag
functions, Python is going to do much of the pre-processing. This lowers
the bar for making a DSL.</p>
<p>Tag authors can begin with simple use cases. After authors gain experience, tag strings can be used to add larger
patterns: lazy evaluation, intermediate representations, registries, and more.</p>
<p>Each of these points also match the teaching of decorators. In that case,
a learner consumes something which applies to the code just after it. They
don’t need to know too much about decorator theory to take advantage of the
utility.</p>
</section>
<section id="common-patterns-seen-in-writing-tag-functions">
<h2><a class="toc-backref" href="#common-patterns-seen-in-writing-tag-functions" role="doc-backlink">Common Patterns Seen In Writing Tag Functions</a></h2>
<section id="structural-pattern-matching">
<h3><a class="toc-backref" href="#structural-pattern-matching" role="doc-backlink">Structural Pattern Matching</a></h3>
<p>Iterating over the arguments with structural pattern matching is the expected
best practice for many tag function implementations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">Decoded</span><span class="p">()</span> <span class="k">as</span> <span class="n">decoded</span><span class="p">:</span>
                <span class="o">...</span> <span class="c1"># handle each decoded string</span>
            <span class="k">case</span> <span class="n">Interpolation</span><span class="p">()</span> <span class="k">as</span> <span class="n">interpolation</span><span class="p">:</span>
                <span class="o">...</span> <span class="c1"># handle each interpolation</span>
</pre></div>
</div>
</section>
<section id="lazy-evaluation">
<h3><a class="toc-backref" href="#lazy-evaluation" role="doc-backlink">Lazy Evaluation</a></h3>
<p>The example tag functions above each call the interpolation’s <code class="docutils literal notranslate"><span class="pre">getvalue</span></code> lambda
immediately. Python developers have frequently wished that f-strings could be
deferred, or lazily evaluated. It would be straightforward to write a wrapper that,
for example, defers calling the lambda until an <code class="docutils literal notranslate"><span class="pre">__str__</span></code> was invoked.</p>
</section>
<section id="memoizing">
<h3><a class="toc-backref" href="#memoizing" role="doc-backlink">Memoizing</a></h3>
<p>Tag function authors have control of processing the static string parts and
the dynamic interpolation parts. For higher performance, they can deploy approaches
for memoizing processing, for example by generating keys.</p>
</section>
<section id="order-of-evaluation">
<h3><a class="toc-backref" href="#order-of-evaluation" role="doc-backlink">Order of Evaluation</a></h3>
<p>Imagine a tag that generates a number of sections in HTML. The tag needs inputs for each
section. But what if the last input argument takes a while? You can’t return the HTML for
the first section until all the arguments are available.</p>
<p>You’d prefer to emit markup as the inputs are available. Some templating tools support
this approach, as does tag strings.</p>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>At the time of this PEP’s announcement, a fully-working implementation is
<a class="reference external" href="https://github.com/lysnikolaou/cpython/tree/tag-strings-rebased">available</a>.</p>
<p>This implementation is not final, as the PEP discussion will likely provide changes.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="enable-exact-round-tripping-of-conv-and-format-spec">
<h3><a class="toc-backref" href="#enable-exact-round-tripping-of-conv-and-format-spec" role="doc-backlink">Enable Exact Round-Tripping of <code class="docutils literal notranslate"><span class="pre">conv</span></code> and <code class="docutils literal notranslate"><span class="pre">format_spec</span></code></a></h3>
<p>There are two limitations with respect to exactly round-tripping to the original
source text.</p>
<p>First, the <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> can be arbitrarily nested:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span><span class="s1">&#39;{x:{a{b</span><span class="si">{c}</span><span class="s1">}}}&#39;</span>
</pre></div>
</div>
<p>In this PEP and corresponding reference implementation, the format_spec
is eagerly evaluated to set the <code class="docutils literal notranslate"><span class="pre">format_spec</span></code> in the interpolation, thereby losing the
original expressions.</p>
<p>While it would be feasible to preserve round-tripping in every usage, this would
require an extra flag <code class="docutils literal notranslate"><span class="pre">equals</span></code> to support, for example, <code class="docutils literal notranslate"><span class="pre">{x=}</span></code>, and a
recursive <code class="docutils literal notranslate"><span class="pre">Interpolation</span></code> definition for <code class="docutils literal notranslate"><span class="pre">format_spec</span></code>. The following is roughly the
pure Python equivalent of this type, including preserving the sequence
unpacking (as used in case statements):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InterpolationConcrete</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">getvalue</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">raw</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">conv</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">format_spec</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Decoded</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">equals</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">getvalue</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_spec</span><span class="p">))</span>
</pre></div>
</div>
<p>However, the additional complexity to support exact round-tripping seems
unnecessary and is thus rejected.</p>
</section>
<section id="no-implicit-string-concatenation">
<h3><a class="toc-backref" href="#no-implicit-string-concatenation" role="doc-backlink">No Implicit String Concatenation</a></h3>
<p>Implicit tag string concatenation isn’t supported, which is <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation">unlike other string literals</a>.</p>
<p>The expectation is that triple quoting is sufficient. If implicit string
concatenation is supported, results from tag evaluations would need to
support the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator with <code class="docutils literal notranslate"><span class="pre">__add__</span></code> and <code class="docutils literal notranslate"><span class="pre">__radd__</span></code>.</p>
<p>Because tag strings target embedded DSLs, this complexity introduces other
issues, such as determining appropriate separators. This seems unnecessarily
complicated and is thus rejected.</p>
</section>
<section id="arbitrary-conversion-values">
<h3><a class="toc-backref" href="#arbitrary-conversion-values" role="doc-backlink">Arbitrary Conversion Values</a></h3>
<p>Python allows only <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code>, or <code class="docutils literal notranslate"><span class="pre">a</span></code> as possible conversion type values.
Trying to assign a different value results in <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>.</p>
<p>In theory, tag functions could choose to handle other conversion types. But this
PEP adheres closely to <a class="pep reference internal" href="../pep-0701/" title="PEP 701 – Syntactic formalization of f-strings">PEP 701</a>. Any changes to allowed values should be in a
separate PEP.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>Thanks to Ryan Morshead for contributions during development of the ideas leading
to tag strings. Thanks also to Koudai Aono for infrastructure work on contributing
materials. Special mention also to Dropbox’s <a class="reference external" href="https://github.com/dropbox/pyxl">pyxl</a>
as tackling similar ideas years ago.</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0750.rst">https://github.com/python/peps/blob/main/peps/pep-0750.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0750.rst">2024-08-11 11:55:15 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#relationship-with-other-peps">Relationship With Other PEPs</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#valid-tag-names">Valid Tag Names</a></li>
<li><a class="reference internal" href="#tags-must-immediately-precede-the-quote-mark">Tags Must Immediately Precede the Quote Mark</a></li>
<li><a class="reference internal" href="#pep-701">PEP 701</a></li>
<li><a class="reference internal" href="#evaluating-tag-strings">Evaluating Tag Strings</a></li>
<li><a class="reference internal" href="#decoded-strings">Decoded Strings</a></li>
<li><a class="reference internal" href="#interpolation">Interpolation</a></li>
<li><a class="reference internal" href="#interpolation-expression-evaluation">Interpolation Expression Evaluation</a></li>
<li><a class="reference internal" href="#id1">Format Specification</a></li>
<li><a class="reference internal" href="#f-string-style-evaluation">f-string-style <code class="docutils literal notranslate"><span class="pre">=</span></code> Evaluation</a></li>
<li><a class="reference internal" href="#tag-function-arguments">Tag Function Arguments</a></li>
<li><a class="reference internal" href="#return-value">Return Value</a></li>
<li><a class="reference internal" href="#function-application">Function Application</a></li>
<li><a class="reference internal" href="#no-empty-decoded-string">No Empty Decoded String</a></li>
</ul>
</li>
<li><a class="reference internal" href="#html-example-of-rich-return-types">HTML Example of Rich Return Types</a></li>
<li><a class="reference internal" href="#tool-support">Tool Support</a><ul>
<li><a class="reference internal" href="#python-semantics-in-tag-strings">Python Semantics in Tag Strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How To Teach This</a></li>
<li><a class="reference internal" href="#common-patterns-seen-in-writing-tag-functions">Common Patterns Seen In Writing Tag Functions</a><ul>
<li><a class="reference internal" href="#structural-pattern-matching">Structural Pattern Matching</a></li>
<li><a class="reference internal" href="#lazy-evaluation">Lazy Evaluation</a></li>
<li><a class="reference internal" href="#memoizing">Memoizing</a></li>
<li><a class="reference internal" href="#order-of-evaluation">Order of Evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#enable-exact-round-tripping-of-conv-and-format-spec">Enable Exact Round-Tripping of <code class="docutils literal notranslate"><span class="pre">conv</span></code> and <code class="docutils literal notranslate"><span class="pre">format_spec</span></code></a></li>
<li><a class="reference internal" href="#no-implicit-string-concatenation">No Implicit String Concatenation</a></li>
<li><a class="reference internal" href="#arbitrary-conversion-values">Arbitrary Conversion Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0750.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
</body>
</html>